import axios from 'axios';
import * as xml2js from 'xml2js';
import { Config } from '../models/Config';
import { RssItem } from '../models/RssItem';

/**
 * Fetches and parses RSS feed data
 * @param config - The configuration object
 * @param since - Optional date to filter items modified since this date
 * @returns Promise<RssItem[]>
 */
export async function fetchRssItems(config: Config, since?: Date): Promise<RssItem[]> {
  try {
    // Use fallback RSS URL if someone still wants to test RSS functionality
    const rssUrl = process.env.RSS_FEED_URL || 'https://www.microsoft.com/releasecommunications/api/v2/m365/rss';
    config.context.log(`Fetching RSS feed from: ${rssUrl}`);
    const response = await axios.get(rssUrl);
    const xml = response.data;

    const parser = new xml2js.Parser({ explicitArray: false });
    const result = await parser.parseStringPromise(xml);

    // Helper functions from the RSS proxy service
    function getText(node: any): string | null {
      if (node == null) return null;
      if (Array.isArray(node)) return getText(node[0]);
      if (typeof node === 'string') return node;
      if (typeof node === 'object') {
        if (node._) return node._;
        // Try to find the first string value
        for (const v of Object.values(node)) {
          if (typeof v === 'string') return v;
        }
      }
      return null;
    }

    function toISOIfDate(s: string | null): string {
      if (!s) return '';
      const d = new Date(s);
      return isNaN(d.getTime()) ? s : d.toISOString();
    }

    function collectTagNames(node: any): string[] {
      if (!node) return [];
      if (Array.isArray(node)) return node.flatMap(collectTagNames);
      if (typeof node === 'string') return [node];
      if (typeof node === 'object') {
        if (node.tagName) {
          if (Array.isArray(node.tagName)) return node.tagName.map(getText).filter(Boolean);
          return [getText(node.tagName)].filter(Boolean);
        }
        // sometimes tags are wrapped as { tag: [...] }
        for (const k of Object.keys(node)) {
          if (['tag', 'tags', 'products', 'cloudInstances', 'releasePhase', 'platforms'].includes(k)) {
            return collectTagNames(node[k]);
          }
        }
        return Object.values(node).flatMap(collectTagNames).filter(Boolean);
      }
      return [];
    }

    const items = result.rss.channel.item || [];
    config.context.log(`Found ${Array.isArray(items) ? items.length : 1} items in RSS feed`);
    
    return (Array.isArray(items) ? items : [items])
      .filter((item: any) => {
        if (!since) return true;
        const pubDate = new Date(getText(item.pubDate) || getText(item.created));
        return pubDate >= since;
      })
      .map((item: any): RssItem => {
        const tags = collectTagNames(item.tags || item.Tags || item.tag);
        const tc = item.tagsContainer || item.tagscontainer || item.TagsContainer || {};

        return {
          id: Number(getText(item.id) || getText(item.ID) || null) || null,
          title: getText(item.title) || '',
          description: getText(item.description) || '',
          moreInfoLink: getText(item.moreInfoLink) || getText(item.moreInfo) || getText(item.link) || '',
          publicDisclosureAvailabilityDate: getText(item.publicDisclosureAvailabilityDate),
          publicPreviewDate: getText(item.publicPreviewDate),
          created: toISOIfDate(getText(item.created) || getText(item.pubDate)),
          publicRoadmapStatus: getText(item.publicRoadmapStatus),
          status: getText(item.status) || '',
          modified: toISOIfDate(getText(item.modified)),
          locale: getText(item.locale),
          tags: {
            products: collectTagNames(tc.products || tc.product || tc.Products),
            cloudInstances: collectTagNames(tc.cloudInstances || tc.cloudInstance || tc.CloudInstances),
            releasePhase: collectTagNames(tc.releasePhase || tc.releasePhase || tc.ReleasePhase),
            platforms: collectTagNames(tc.platforms || tc.platform || tc.Platforms),
          },
          link: getText(item.link) || '',
          pubDate: toISOIfDate(getText(item.pubDate)),
          guid: item.guid && item.guid._ ? item.guid._ : getText(item.guid) || ''
        };
      });

  } catch (error) {
    config.context.error(`Error fetching RSS feed: ${error.message}`);
    throw error;
  }
}
